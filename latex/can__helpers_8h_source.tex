\hypertarget{can__helpers_8h_source}{}\doxysection{can\+\_\+helpers.\+h}
\label{can__helpers_8h_source}\index{/github/workspace/driver/can/include/huron/driver/can/can\_helpers.h@{/github/workspace/driver/can/include/huron/driver/can/can\_helpers.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ * Original source from: https://github.com/odriverobotics/ODrive/tree/master}}
\DoxyCodeLine{3 \textcolor{comment}{ * */}}
\DoxyCodeLine{4 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{5 }
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <stdint.h>}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{keyword}{struct }\mbox{\hyperlink{structcan__Message__t}{can\_Message\_t}} \{}
\DoxyCodeLine{12   uint32\_t \textcolor{keywordtype}{id} = 0x000;  \textcolor{comment}{// 11-\/bit max is 0x7ff, 29-\/bit max is 0x1FFFFFFF}}
\DoxyCodeLine{13   \textcolor{keywordtype}{bool} isExt = \textcolor{keyword}{false};}
\DoxyCodeLine{14   \textcolor{keywordtype}{bool} rtr = \textcolor{keyword}{false};}
\DoxyCodeLine{15   uint8\_t len = 8;}
\DoxyCodeLine{16   uint8\_t buf[8] = \{0, 0, 0, 0, 0, 0, 0, 0\};}
\DoxyCodeLine{17 \};}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{keyword}{struct }\mbox{\hyperlink{structcan__Signal__t}{can\_Signal\_t}} \{}
\DoxyCodeLine{20   \textcolor{keyword}{const} uint8\_t startBit;}
\DoxyCodeLine{21   \textcolor{keyword}{const} uint8\_t length;}
\DoxyCodeLine{22   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isIntel;}
\DoxyCodeLine{23   \textcolor{keyword}{const} \textcolor{keywordtype}{float} factor;}
\DoxyCodeLine{24   \textcolor{keyword}{const} \textcolor{keywordtype}{float} offset;}
\DoxyCodeLine{25 \};}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{keyword}{struct }\mbox{\hyperlink{structcan__Cyclic__t}{can\_Cyclic\_t}} \{}
\DoxyCodeLine{28   uint32\_t cycleTime\_ms;}
\DoxyCodeLine{29   uint32\_t lastTime\_ms;}
\DoxyCodeLine{30 \};}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{33 \textcolor{keyword}{constexpr} T can\_getSignal(\mbox{\hyperlink{structcan__Message__t}{can\_Message\_t}} msg, \textcolor{keyword}{const} uint8\_t startBit,}
\DoxyCodeLine{34               \textcolor{keyword}{const} uint8\_t length, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isIntel) \{}
\DoxyCodeLine{35   uint64\_t tempVal = 0;}
\DoxyCodeLine{36   uint64\_t mask = length < 64 ? (1ULL << length) -\/ 1ULL : -\/1ULL;}
\DoxyCodeLine{37 }
\DoxyCodeLine{38   \textcolor{keywordflow}{if} (isIntel) \{}
\DoxyCodeLine{39     std::memcpy(\&tempVal, msg.buf, \textcolor{keyword}{sizeof}(tempVal));}
\DoxyCodeLine{40     tempVal = (tempVal >> startBit) \& mask;}
\DoxyCodeLine{41   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{42     std::reverse(std::begin(msg.buf), std::end(msg.buf));}
\DoxyCodeLine{43     std::memcpy(\&tempVal, msg.buf, \textcolor{keyword}{sizeof}(tempVal));}
\DoxyCodeLine{44     tempVal = (tempVal >> (64 -\/ startBit -\/ length)) \& mask;}
\DoxyCodeLine{45   \}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47   T retVal;}
\DoxyCodeLine{48   std::memcpy(\&retVal, \&tempVal, \textcolor{keyword}{sizeof}(T));}
\DoxyCodeLine{49   \textcolor{keywordflow}{return} retVal;}
\DoxyCodeLine{50 \}}
\DoxyCodeLine{51 }
\DoxyCodeLine{52 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{53 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{void} can\_setSignal(\mbox{\hyperlink{structcan__Message__t}{can\_Message\_t}}\& msg, \textcolor{keyword}{const} T\& val,}
\DoxyCodeLine{54                  \textcolor{keyword}{const} uint8\_t startBit, \textcolor{keyword}{const} uint8\_t length,}
\DoxyCodeLine{55                  \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isIntel) \{}
\DoxyCodeLine{56   uint64\_t valAsBits = 0;}
\DoxyCodeLine{57   std::memcpy(\&valAsBits, \&val, \textcolor{keyword}{sizeof}(val));}
\DoxyCodeLine{58 }
\DoxyCodeLine{59   uint64\_t mask = length < 64 ? (1ULL << length) -\/ 1ULL : -\/1ULL;}
\DoxyCodeLine{60 }
\DoxyCodeLine{61   \textcolor{keywordflow}{if} (isIntel) \{}
\DoxyCodeLine{62     uint64\_t data = 0;}
\DoxyCodeLine{63     std::memcpy(\&data, msg.buf, \textcolor{keyword}{sizeof}(data));}
\DoxyCodeLine{64 }
\DoxyCodeLine{65     data \&= \string~(mask << startBit);}
\DoxyCodeLine{66     data |= valAsBits << startBit;}
\DoxyCodeLine{67 }
\DoxyCodeLine{68     std::memcpy(msg.buf, \&data, \textcolor{keyword}{sizeof}(data));}
\DoxyCodeLine{69   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{70     uint64\_t data = 0;}
\DoxyCodeLine{71     std::reverse(std::begin(msg.buf), std::end(msg.buf));}
\DoxyCodeLine{72     std::memcpy(\&data, msg.buf, \textcolor{keyword}{sizeof}(data));}
\DoxyCodeLine{73 }
\DoxyCodeLine{74     data \&= \string~(mask << (64 -\/ startBit -\/ length));}
\DoxyCodeLine{75     data |= valAsBits << (64 -\/ startBit -\/ length);}
\DoxyCodeLine{76 }
\DoxyCodeLine{77     std::memcpy(msg.buf, \&data, \textcolor{keyword}{sizeof}(data));}
\DoxyCodeLine{78     std::reverse(std::begin(msg.buf), std::end(msg.buf));}
\DoxyCodeLine{79   \}}
\DoxyCodeLine{80 \}}
\DoxyCodeLine{81 }
\DoxyCodeLine{82 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{83 \textcolor{keywordtype}{void} can\_setSignal(\mbox{\hyperlink{structcan__Message__t}{can\_Message\_t}}\& msg, \textcolor{keyword}{const} T\& val, \textcolor{keyword}{const} uint8\_t startBit,}
\DoxyCodeLine{84            \textcolor{keyword}{const} uint8\_t length, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isIntel, \textcolor{keyword}{const} \textcolor{keywordtype}{float} factor,}
\DoxyCodeLine{85            \textcolor{keyword}{const} \textcolor{keywordtype}{float} offset) \{}
\DoxyCodeLine{86   T scaledVal = \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}((val -\/ offset) / factor);}
\DoxyCodeLine{87   can\_setSignal<T>(msg, scaledVal, startBit, length, isIntel);}
\DoxyCodeLine{88 \}}
\DoxyCodeLine{89 }
\DoxyCodeLine{90 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{91 \textcolor{keywordtype}{float} can\_getSignal(\mbox{\hyperlink{structcan__Message__t}{can\_Message\_t}} msg, \textcolor{keyword}{const} uint8\_t startBit,}
\DoxyCodeLine{92             \textcolor{keyword}{const} uint8\_t length, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isIntel,}
\DoxyCodeLine{93             \textcolor{keyword}{const} \textcolor{keywordtype}{float} factor, \textcolor{keyword}{const} \textcolor{keywordtype}{float} offset) \{}
\DoxyCodeLine{94   T retVal = can\_getSignal<T>(msg, startBit, length, isIntel);}
\DoxyCodeLine{95   \textcolor{keywordflow}{return} (retVal * factor) + offset;}
\DoxyCodeLine{96 \}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{99 \textcolor{keywordtype}{float} can\_getSignal(\mbox{\hyperlink{structcan__Message__t}{can\_Message\_t}} msg, \textcolor{keyword}{const} \mbox{\hyperlink{structcan__Signal__t}{can\_Signal\_t}}\& signal) \{}
\DoxyCodeLine{100   \textcolor{keywordflow}{return} can\_getSignal<T>(msg, signal.startBit, signal.length, signal.isIntel,}
\DoxyCodeLine{101               signal.factor, signal.offset);}
\DoxyCodeLine{102 \}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{105 \textcolor{keywordtype}{void} can\_setSignal(\mbox{\hyperlink{structcan__Message__t}{can\_Message\_t}}\& msg, \textcolor{keyword}{const} T\& val,}
\DoxyCodeLine{106            \textcolor{keyword}{const} \mbox{\hyperlink{structcan__Signal__t}{can\_Signal\_t}}\& signal) \{}
\DoxyCodeLine{107   can\_setSignal(msg, val, signal.startBit, signal.length, signal.isIntel,}
\DoxyCodeLine{108         signal.factor, signal.offset);}
\DoxyCodeLine{109 \}}

\end{DoxyCode}
